function dijkstra(grid, start_node, goal_node)
    % Dijkstra algorithm to find the shortest path in a grid
    % grid: 2D grid map (0: free, 1: obstacle)
    % start_node: [row, col] of the start node
    % goal_node: [row, col] of the goal node
    
    [rows, cols] = size(grid);
    max_cost = inf;
    
    % Initialize cost and predecessor matrices
    cost_map = max_cost * ones(rows, cols);
    cost_map(start_node(1), start_node(2)) = 0;
    
    % Initialize the visited list
    visited = [];
    % Priority queue for nodes to visit
    pq = PriorityQueue();
    pq.insert(start_node, 0);
    
    % Initialize the predecessors map to reconstruct the path
    predecessors = cell(rows, cols);
    
    % Possible moves (8 directions)
    moves = [-1, 0; -1, 1; 0, 1; 1, 1; 1, 0; 1, -1; 0, -1; -1, -1];
    move_costs = [1, sqrt(2), 1, sqrt(2), 1, sqrt(2), 1, sqrt(2)];
    
    while ~pq.isEmpty()
        [current, current_cost] = pq.extractMin();
        if isempty(visited) || ~ismember(current, visited,"rows")
            if current ~= start_node
            visited = [visited; current];
        end
        
        if isequal(current, goal_node)
            break;
        end
        
        for i = 1:size(moves, 1)
            neighbor = current + moves(i, :);
            if neighbor(1) < 1 || neighbor(1) > rows || neighbor(2) < 1 || neighbor(2) > cols
                continue;
            end
            if grid(neighbor(1), neighbor(2)) == 1
                continue;
            end

            if moves(i,1) ~= 0 && moves(i,2) ~= 0
                if grid(current(1),neighbor(2)) == 1 || grid(neighbor(1),current(2)) == 1
                    continue
                end
            end

            new_cost = current_cost + move_costs(i);

            if new_cost < cost_map(neighbor(1), neighbor(2))
                cost_map(neighbor(1), neighbor(2)) = new_cost;
                pq.insert(neighbor, new_cost);
                predecessors{neighbor(1), neighbor(2)} = current;
            end
        end
    end
    
    % Construct Path
    path = [];
    if ~isnan(predecessors{goal_node(1), goal_node(2)})
        current = goal_node;
        while ~isequal(current, start_node)
            % Easy to track back
            path = [current; path];
            current = predecessors{current(1), current(2)};
        end
        path = [start_node; path];
        cost = cost_map(goal_node(1), goal_node(2));
    else
        cost = max_cost;
    end
    visualize_grid(grid, path, cost, visited, start_node, goal_node);
end


function visualize_grid(grid, path, cost, visited, start, goal)
    % Visualize the grid and the path

    % Check if the correct number of arguments are provided
    if nargin < 3
        error('Not enough input arguments. Expected grid, path, and cost.');
    end
    
    % Get the size of the grid
    [rows, cols] = size(grid);
    
    % Create a white background image
    img = ones(rows, cols, 3); 
    
    % Set obstacles to black
    obstacle_mask = (grid == 1);
    img(repmat(obstacle_mask, [1, 1, 3])) = 0; % Set all channels to 0 for obstacles
    
    % Ensure path contains valid indices
    if isempty(path)
        error('Path is empty or invalid.');
    end
    
    % Check if path indices are within grid bounds
    if any(path(:,1) < 1 | path(:,1) > rows) || any(path(:,2) < 1 | path(:,2) > cols)
        error('Path indices are out of bounds.');
    end
    
    % % Convert (row, col) to linear indices
    % linear_indices = sub2ind([rows, cols], path(:,1), path(:,2));
    % 
    % % Set path positions to red
    % for i = 1:length(linear_indices)
    %     img(path(i,1), path(i,2), :) = [1, 0, 0];
    % end

    % Fill visited nodes with grey color
    % for i = 1:size(visited, 1)
    %     rectangle('Position', [visited(i, 2) - 0.5, visited(i, 1) - 0.5, 1, 1], 'FaceColor', [0.5, 0.5, 0.5, 0.5], 'EdgeColor', 'none');
    % end

    % Draw the start and goal nodes
    img = insertShape(img, 'FilledCircle', [start(2), start(1), 3], 'Color', 'green', 'Opacity', 1);
    img = insertShape(img, 'FilledCircle', [goal(2), goal(1), 3], 'Color', 'blue', 'Opacity', 1);
    
    % Mark visited nodes with gray
    for i = 1:size(visited, 1)
        img(visited(i,1), visited(i,2), :) = [0.5, 0.5, 0.5]; % Gray color
    end
    % Draw the path
    % plot(path(:, 2), path(:, 1), 'r', 'LineWidth', 2);
    for i = 2:length(path)
        line([path(i-1, 2), path(i, 2)], [path(i-1, 1), path(i, 1)], 'Color', 'r', 'LineWidth', 2);
    end
    % Display the grid
    figure;
    imshow(img, 'InitialMagnification', 'fit');
    % hold on;

    % Add title
    text(25, -3, 'Dijkstra', 'FontSize', 14, 'FontWeight', 'bold', 'HorizontalAlignment', 'center');
    text(25, -1, ['Cost: ', num2str(cost)], 'FontSize', 12, 'HorizontalAlignment', 'center');
    
    % title(['Dijkstra\n Cost: ', num2str(cost)],'Interpreter','none');
    saveas(gcf, 'dijkstra.png');
    % hold off;
end

